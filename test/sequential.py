sequential_prompt = """
我想写一本玄幻小说，名为《斗破苍穹》。我想以第一人称视角进行写作。请你生成这本小说的目录。
大致的故事为：
《斗破苍穹》的故事发生在一个充满“斗气”的大陆上，讲述了名为萧炎的少年，年少时被视为废物（无法修炼斗气），接着奋起抗争，展开冒险（修炼）之旅，凭借自身努力、高人指导、奇珍异宝的帮助，不断收集“异火”（一种威力极大的火焰），持续提升丹药炼制水平（成为顶级炼药师）和斗气（战斗能量）修炼水平，战斗能力逐步加强。最后，主角萧炎不仅洗刷当年的耻辱，还一跃成为斗气大陆上的最强者——“斗帝”，成为该世界秩序守护者和最高权力拥有者。
任务设定：
萧炎
本书主角，穿越者，带着成年人的记忆从地球转生到斗气大陆。 [2]本为天才少年，但从十一岁那年开始连续三年多莫名其妙地退化成斗之气三段，从此逐渐沦为遭人白眼的废柴。之后得知原因竟是有一个神秘的灵魂“药老”藏在萧炎母亲的遗物戒指中不断吸收他的斗之气，在药老停止吸收斗之气并答应帮他重展天资后，一年时间内突破至斗之气九段，震惊全城。后来萧炎踏上了修炼之旅，以他的执着与信念闯荡大陆，一路历经坎坷，向着巅峰强者之途迈进，最终收服天下万火，成为万火之帝，号"炎帝"。自尊心强，恩怨分明，早期饱受冷眼与嘲讽，性格较为激进，冲动易怒，后期随着实力的增强与阅历的丰富，逐渐成长为性格沉稳冷静，处事周全的强者
药尘
男主角萧炎的老师。人称药老、药尊者，后称药圣，拥有“骨灵冷火”（后赠与萧炎）。星陨阁极少露面的阁主（副阁主为至交好友风尊者--风闲），初为九转斗尊巅峰强者，九品炼药宗师。因遭叛徒韩枫出卖而落难成为灵魂状态，潜伏于一个戒指中，后戒指辗转落入萧炎之手，在吸收萧炎三年斗之气后恢复意识。之后药尘一路帮助萧炎成长，将毕生斗技和炼药术倾囊相授，多次救萧炎于危难之中，成为萧炎一生中最敬重的老师。经萧炎炼制斗尊强者骨骸外加造化圣者手臂骨而复活，其实力提升至半圣，在服用了萧炎带回来的黄泉妖圣精血后晋阶成一星斗圣。
萧薰儿（古熏儿）
萧炎的两位妻子之一，清纯可人，高傲冷漠。古族的大小姐，自小在萧家长大，与萧炎无血缘关系，其父在她幼年时将她送往萧家，命她暗中查询萧家“陀舍古帝玉”碎片的下落并暗中夺得。因为幼时萧炎偷偷进入其房间，被其误会是在用斗气帮她温养身体而爱上他。在萧炎被视为废物的三年里从未放弃他，自始至终相信萧炎会成为超越巅峰的强者。一直鼓励萧炎并且尽自己最大可能地帮助他，萧炎也因为薰儿的不离不弃而被感动。
其身份背景为古族族长（古元）千金，是古族难得神品血脉拥有者，天赋异禀，拥有异火“金帝焚天炎”，依靠传承的斗帝血脉和古族家族力量实力暴涨得很快。先在迦南学院等萧炎两年，后又为保护萧炎而返回古界。在得知萧炎踏足中州时，第一时间前往与萧炎相见，并于冰河谷谷主（冰尊者）与魂殿青海尊者手中救下萧炎和天火尊者等人。后因家族原因，又不得不离开。主角实力提升后前往古界，两人终于再次相见，并获得其父的默许。书末尾和主角以及彩鳞一起举办了一场盛大的婚礼。
彩鳞（美杜莎女王）
萧炎的两位妻子之一，冷艳绝美，倾国倾城。加玛帝国塔戈尔大沙漠中的蛇人部落女王，其凶名与艳名在加玛帝国几乎人尽皆知。在夺取利用“青莲地心火”冲击斗宗时进化为上古异兽七彩吞天蟒，随后本体被萧炎收入带走，从此与七彩吞天蟒成为共生状态并陪伴在萧炎身边。
萧炎前往云岚宗赴三年之约时美杜莎现身将云山惊退，后为取得丹药而与萧炎达成协议，常常成为萧炎的保命符。在天焚练气塔底部时受到“陨落心炎”的煅烧而与七彩吞天蟒的灵魂融为一体，但同时不幸地被主角强暴， [3]并因此怀孕。本想杀了主角，但由于融合了吞天蟒灵魂使其受到吞天蟒影响而无法对主角下手。 在经历了一系列事件后最终认命决定跟随主角，并且在萧炎面前显露出女人的一面。
在萧炎冲击斗皇时为其护法，后萧炎离开西北前往中州后由彩鳞坐镇炎盟，一个人扛起炎盟，不惜性命守着他的亲人和加玛帝国，之后生下了他们的女儿萧潇。一晃十数年光阴，加玛帝国遭魂殿势力入侵，彩鳞率领炎盟抵抗魂殿的侵略，实力此时已达八星斗尊（化为七彩吞天蟒后的实力），所幸萧炎在危机关头赶到，事后彩鳞与萧炎办了一场简单婚礼并随萧炎返回星陨阁。在九幽地冥蟒族的九幽黄泉闭关数年后，彩鳞成功突破至四星斗圣，并进化为九彩吞天蟒。出关后与萧炎一起对抗天妖凰族。与萧炎生有一女，名为萧潇（本体与吞天蟒共生），是萧炎最天赋惊人的孩子，惊才绝艳。书末尾和主角以及古薰儿一起举办了一场盛大的婚礼。
小医仙
萧炎在魔兽山脉历练时认识的少女，对萧炎有特殊的感情，萧炎的红颜知己之一。体质为“厄难毒体”，万毒不侵，修炼《七彩毒经》，无需苦修，只需要不间断地吃毒药，便能快速地提升实力，但体内的毒素会不断累积，导致终有一天会彻底爆发出来。
曾与萧炎在魔兽山谷中共同生活过一段时间，后来独自前往出云帝国历练。再次登场时已成为毒宗宗主天毒女，实力达到四星斗宗。与萧炎前往中州时遭遇了空间风暴而分离，后因“厄难毒体”而被冰河谷追杀，留难到落神涧，被萧炎所救，此时已是六星斗宗。随后在萧炎的帮助下凝练毒丹，成功控制“厄难毒体”并晋阶至二星斗尊。经药老指点，小医仙在一位同样拥有“厄难毒体”的前辈墓前修炼其自创的控制“厄难毒体”之功法，将“厄难毒体”彻底炼化，实力提升至七星斗尊。后来服用了黄泉妖圣精血，顺利晋阶成一星斗圣。大结局时小医仙独自回到青山镇行医，后被萧炎邀请回乌坦城。
纳兰嫣然
纳兰家族的大小姐，云岚宗的少宗主，曾与萧炎指腹为婚。个性独立，主张自由恋爱，极端反感长辈包办婚姻。为了拥有自己的幸福与选择命运的权利，十五岁那年在爷爷纳兰桀的不知情下前往萧家退婚，使得萧炎颜面大失。萧炎一怒之下休妻，并发誓三年之后上云岚宗一洗当日之辱。
加玛帝国炼药师大会时纳兰嫣然对萧炎假扮的岩枭萌生了情愫，但萧炎的冷漠让其不思其解。后在与萧炎的三年之约一战中落败，期间发现了岩枭的身份并认识到自己的感情，但依旧不后悔自己当初退婚的决定。 [7-9]（番外中明确表明不后悔退婚 [10]）。
云岚宗被灭后和云韵一起离开了加玛帝国，后与老师一起加入了花宗。在天目山脉历练时与萧炎重逢，经过时间的冲刷，二人对当初的过节早已淡然。途中在萧炎的帮助下通过了“鼠潮音波阵”的闯关，得到了进入天山血潭中洗礼的名额，实力晋阶到斗宗。大结局时萧炎邀请云韵回到加玛帝国，纳兰嫣然也跟着云韵回去。
云韵
纳兰嫣然的老师，美丽高雅，萧炎的红颜知己之一。曾任云岚宗宗主，初登场时为三星斗皇，于魔兽山谷中与萧炎邂逅，是主角认识的第一个斗皇强者。在实力被封印的情况下被主角所救，分别时将贴身内甲赠与主角。
对萧炎很有好感，萧炎初期亦对其怀有些许情愫，两人之间的感情错综复杂。萧炎与云岚宗决战前夕，云山为了拉拢丹王古河而控制住云韵并将她许配给古河，婚礼当天萧炎杀上云岚宗，打败古河并击杀云山，宗门被灭后云韵与萧炎在云岚山上相处了几天，最后在内心挣扎下离开了加玛帝国。
云韵到达中州后在一次偶然间得到了花宗宗主花婆婆传承毕生斗气和宗主之位，但却遭到花婆婆养女花锦迫害，后在萧炎的帮助下夺回宗主之位，成为花宗宗主。在将花婆婆传承的斗气完全炼化后实力晋级为八星斗尊。后来率领花宗加入天府联盟，共同抵抗魂殿。大结局时萧炎邀请云韵回到加玛帝国。
"""

sequential_content_prompt = """
## rule
目录存储于json数据结构中，并用<JSON></JSON>封装，例如：
<JSON>
{
        "content":[
                {"id": 0, "heading": "岳阳县水系连通及农村水系综合整治工程建设项目环境影响报告书", "level": 0},
                {"id": 1, "heading": "概述", "level": 1},
                {"id": 2, "heading": "分析判定相关环保政策", "level": 2},
                {"id": 3, "heading": "产业政策相符性分析", "level": 3},
                {"id": 4, "heading": "法律法规符合性分析", "level": 3},
                {"id": 5, "heading": "与相关规划符合性分析", "level": 3},
                {"id": 6, "heading": "项目环评报告书的主要结论", "level": 2},
                {"id": 7, "heading": "结论与建议", "level": 1},
                {"id": 8, "heading": "项目概况", "level": 2},
                {"id": 9, "heading": "环境管理", "level": 3},
                {"id": 10, "heading": "主要环保措施", "level": 2},
                {"id": 11, "heading": "环境影响经济损益分析", "level": 3},
                {"id": 12, "heading": "环评总结论", "level": 3}
        ]
}
<JSON>

各个字段的含义
- "id"：表示每个目录项的唯一标识符，可以用来区别不同的目录项。
- "heading"：表示每个目录项的标题，描述了目录项的内容。
- "level"：代表目录项的等级或深度。"0"通常表示这是一级目录，"1"表示二级目录，"2"表示三级目录，以此类推。比如"id"为0的目录项的"level"为0, 它是文本的title; "id"为1的目录项的"level"为1, 它是一级标题。这个字段可以帮助我们了解目录的层次结构。

## task
Q: 我想写一本以月球为主题的科幻小说《月影之下》，请你生成小说《月影之下》的目录，并详细说明目录项的依赖关系。
A: 
<JSON>
{
    "content":[
        {"id": 0, "heading": "月影之下",  "level": 0},
        {"id": 1, "heading": "序言", : 1},
        {"id": 2, "heading": "神秘的邀请函","level": 1},
        {"id": 3, "heading": "地球上的准备", "level": 1},
        {"id": 4, "heading": "太空之旅启程", "level": 1},
        {"id": 5, "heading": "宇宙中的异样", "level": 1},
        {"id": 6, "heading": "月亮的邀请", "level": 1},
        {"id": 7, "heading": "落月的秘密", "level": 1},
        {"id": 8, "heading": "月影村落", "level": 1},
        {"id": 9, "heading": "月影族人", "level": 1},
        {"id": 10, "heading": "神秘的传说", "level": 1},
        {"id": 11, "heading": "月亮矿石的秘密", "level": 1},
        {"id": 12, "heading": "危险的决定", "level": 1},
        {"id": 13, "heading": "再见，地球", "level": 1},
        {"id": 14, "heading": "归航中的挑战", "level": 1},
        {"id": 15, "heading": "勇敢的牺牲", "level": 1},
        {"id": 16, "heading": "安全归航", "level": 1},
        {"id": 17, "heading": "回归之后", "level": 1},
        {"id": 18, "heading": "新的前景", "level": 1},
        {"id": 19, "heading": "解开的秘密", "level": 1},
        {"id": 20, "heading": "结语", "dep": "level": 1}
    ]
}
</JSON>

Q: 我想写一则以关于特朗普在2020美国总统大选中落选的Opinion article，标题为《美国大选2020|特朗普落选的三个原因》，请你生成Opinion article的目录。
A:
<JSON>
{
    "content":[
        {"id": 0, "heading": "美国大选2020|特朗普落选的三个原因", "level": 0},
        {"id": 1, "heading": "引言", "level": 1},
        {"id": 2, "heading": "第一原因：新冠疫情的处理", "level": 1},
        {"id": 3, "heading": "新冠疫情的严重性", "level": 2},
        {"id": 4, "heading": "特朗普政府的应对措施和问题", "level": 2},
        {"id": 5, "heading": "公众对特朗普政府应对疫情的评价", "level": 2},
        {"id": 6, "heading": "第二原因：贸易战问题", "level": 1},
        {"id": 7, "heading": "特朗普政权实施的贸易政策", "level": 2},
        {"id": 8, "heading": "贸易政策带来的影响", "level": 2},
        {"id": 9, "heading": "公众对特朗普贸易战的反应", "level": 2},
        {"id": 10, "heading": "第三原因：种族问题", "level": 1},
        {"id": 11, "heading": "特朗普政府下的种族紧张", "level": 2},
        {"id": 12, "heading": "种族问题对选民的影响", "level": 2},
        {"id": 13, "heading": "美国公众对特朗普种族问题立场的评价", "level": 2},
        {"id": 14, "heading": "结论", "level": 1}
    ]
}
</JSON>

"""

sequential_write_prompt = """
<role>
你是一名写作专家
</role>
<rule>
你正在写作<{title}>的目录项`{heading}`的正文内容。
content: 是文章的目录
</rule>
<constraints>
1. 你只能返回markdoWn格式的文本
2. 你的返回的正文中不能含有 #, ##, ###, ####, #####, ###### 等markdown heading命令
</constraints>
<content>
{content}
</content>
<task>
Q: 请根据content写作目录项`{heading}`的正文内容。
A:
"""


from pathlib import Path		
import sys
root_path = Path(__file__).parent.parent    # 项目根目录    /DocDoc
cur_path = Path(__file__).parent    # 当前目录    /DocDoc/test
sys.path.append(str(cur_path))
sys.path.append(str(root_path))

from LLMs import ChatGLM
from core.Agent import Writer
from core.Agent import ContentExpert
import time

# init
llm = ChatGLM()
content_expert = ContentExpert(llm)    

class Heading:
    def __init__(self, id, heading, level):
        self.id:int = id
        self.heading:str = heading
        self.level:int = level
        self.text:str = None

# 生成目录
def genContent(prompt:str) -> list[Heading]:
    prompt = sequential_content_prompt + "Q: " + prompt + "\nA:" 
    response:str = llm(prompt)
    json_data:dict = content_expert.extract_json_from_str(response)
    content:list[Heading] = []
    for row in json_data['content']:
        heading_obj = Heading(row['id'], row['heading'], row['level'])
        content.append(heading_obj)
    return content

# 打印目录
def printContent(content:list[Heading]) -> None:
    for i in range(len(content)):
        print(content[i].id, content[i].heading, content[i].level)

# 撰写正文
def write(title:str, heading:str, content: list[Heading]) -> str:
    prompt:str =  sequential_write_prompt.format(title=title, heading=heading, content=content)
    print(prompt)
    text:str = llm(prompt)
    # text = "测试"
    return text

# 组装全文
def doc_assemble(content:list[Heading]) -> str:
    full_text = ""
    title = content[0]
    full_text += f"**{title.heading}**\n"
    for heading in content:
        if heading.level > 0:
            # print("heading:", heading.heading, ", heading->level =", heading.level)
            full_text += "#" * heading.level + " " + heading.heading + "\n"
            if heading.text:
                full_text += heading.text + "\n"
    return full_text

def get_current_time() -> str:
    import time
    import pytz
    from datetime import datetime

    # 获取当前时间的时间戳
    start_time = time.time()

    # 将时间戳转换为datetime对象，并设置时区为UTC
    utc_time = datetime.utcfromtimestamp(start_time).replace(tzinfo=pytz.utc)

    # 强制设置时区为东八区
    tz = pytz.timezone('Asia/Shanghai')
    local_time = utc_time.astimezone(tz)

    # 将强制设置时区后的时间格式化为24小时制的时间字符串
    formatted_time = local_time.strftime("%Y-%m-%d %H:%M:%S")
    return formatted_time

def content_to_jsonStr(content:list[Heading]) -> str: 
    json_str = "{\n\t\"content\":[\n"
    length = len(content)
    for i in range(length - 1):
        json_str += '\t\t' + '{"id": ' + str(content[i].id) + ', "heading": "' + content[i].heading +  ', "level": ' + str(content[i].level) + '},'
        json_str += '\n'
    json_str += '\t\t' + '{"id": ' + str(content[length - 1].id) + ', "heading": "' + content[length - 1].heading + ', "level": ' + str(content[length - 1].level) + '}'
    json_str += '\n'
    json_str += '\t]\n}'
    return json_str

# ------------------ main ------------------

# 记录程序开始运行时间，使用时间戳生成唯一的文件名
start_time = time.time()
timestamp = time.strftime("%Y%m%d%H%M%S")

# -- init --
# llm = ChatGLM()

# -- content --

content:list[Heading] = genContent(sequential_prompt)
printContent(content)   # 打印 content

# -- write --
title:str = content[0].heading   # 获取文章标题
content_str = content_to_jsonStr(content)  # 将 content 转换为 string 格式的 Json
print(content_str)

# 测试：查看写作的prompt是否正常
# h = content[1]
# heading:str = h.heading
# text:str = write(title, heading, content_str)
# h.text = text 

for i in range(1, len(content)):   # i starts from 1
    h = content[i]
    heading:str = h.heading
    text:str = write(title, heading, content_str)
    h.text = text 

# -- assemble full_text --  
full_text:str = doc_assemble(content)

# -- store_to_disk --
# 计算程序运行时间，并保留两位小数
end_time = time.time()

# store to disk
markdown_file_path = str(cur_path) + f'/output/sequential/seq_genDoc_{timestamp}.md'

# -- 计算程序运行时间 -- 
run_time_seconds = round(end_time - start_time, 2) # 秒
# 将秒数转换为分钟和秒的形式
minutes = int(run_time_seconds // 60)
seconds = run_time_seconds % 60
# 格式化为 n分m秒 的形式
run_time_formatted = f"{minutes}分{seconds:.2f}秒"
log =  f"算法耗时：`{run_time_formatted}\n"

print(markdown_file_path)
with open(markdown_file_path, 'a', encoding='utf-8') as file:
        file.write(f"运行开始自: {get_current_time()}\n" + f"所用模型：`gpt-4o-2924-05-13`, 所用Embed_model:`None`\n") 
        file.write(log)
        file.write(full_text)   
